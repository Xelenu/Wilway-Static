<!DOCTYPE html>
<html style="width: 100%; height: 100%">

<head>
	<meta charset="UTF-8">
	<title>Ruffle: Emulating Flash</title>
	<meta name="robots" content="noindex, nofollow, noimageindex" />
	<style>
		body {
			background-color: black;
		}

		#ruffle_content {
			display: flex;
			align-items: center;
			text-align: center;
		}

		#warnings {
			display: none;
			pointer-events: none;
		}

		.small #warnings {
			display: block;
			position: absolute;
			color: white;
			width: 100%;
			font-family: arial, helvetica, sans-serif;
			font-weight: bold;
			font-size: 14px;
		}

		#warning-text {
			margin-bottom: 160px;
			margin-top: 4px;
		}

		#startFlashBtn {
			display: block;
			margin: 0px auto;
		}

		div.icon {
			position: relative;
			display: inline-block;
		}

		div.icon>img {
			max-width: 100%;
			min-width: 360px;
		}

		.small div.icon {
			width: 220px;
			display: inline-flex;
		}

		.small div.icon>img {
			width: 220px;
			min-width: 220px;
		}

		ruffle-player {
			margin: 0px auto;
		}

		#startFlashBtn div.play-over {
			position: absolute;
			top: 0px;
			left: 0px;
			width: 100%;
			height: 100%;
			background-color: rgba(0, 0, 0, 0.2);
		}

		#startFlashBtn div.play-over::before {
			content: "";
			position: absolute;
			display: block;
			width: 120px;
			height: 120px;
			border-radius: 9999px;
			border: 12px solid rgba(255, 255, 255, 0.7);
			margin-top: -66px;
			margin-left: -66px;
			top: 50%;
			left: 50%;
		}

		#startFlashBtn div.play-over::after {
			content: "";
			position: absolute;
			display: block;
			width: 60px;
			height: 0px;
			border: 40px solid rgba(255, 255, 255, 0.5);
			border-width: 40px 0px 40px 80px;
			border-color: transparent transparent transparent rgba(255, 255, 255, 0.7);
			top: 50%;
			left: 50%;
			margin-left: -26px;
			margin-top: -34px;
		}

		#startFlashBtn:hover div.play-over {
			background-color: rgba(0, 0, 0, 0.5);
		}

		#startFlashBtn:hover div.play-over::before {
			border: 12px solid white;
		}

		#startFlashBtn:hover div.play-over::after {
			border-color: transparent transparent transparent white;
		}

		#startFlashBtn div.play-over::before,
		#startFlashBtn div.play-over::after {
			filter: drop-shadow(9px 4px 6px rgba(0, 0, 0, 0.65));
		}

		.small #startFlashBtn {
			padding-bottom: 40px;
			margin-top: 40px;
		}
		.small #startFlashBtn div.play-over::before {
			width: 60px;
			height: 60px;
			border-radius: 9999px;
			border-width: 6px;
			margin-top: -33px;
			margin-left: -33px;
		}

		.small #startFlashBtn div.play-over::after {
			width: 30px;
			border-width: 20px 0px 20px 40px;
			margin-top: -17px;
			margin-left: -13px;
		}

		.small #startFlashBtn div.play-over::before,
		.small #startFlashBtn div.play-over::after {
			filter: drop-shadow(4.5px 2px 3px rgba(0, 0, 0, 0.65));
		}

		.small #startFlashBtn:hover div.play-over::before {
			border-width: 6px;
		}
	</style>
</head>

<body style="margin: 0px; padding: 0px; width: 100%; height: 100%">
	<div id="ruffle_content" style="width:100%; height:100%">
		<a href="#" id="startFlashBtn">START</a>
		<div id="warnings">
			<p id="warning-text">⚠️ May not be compatible with your device.</p>
			<p id="play-anyway">Play Anyway?</p>
		</div>
	</div>
	<script>

		// this is a relic from when we needed to put this call direct in the flash games.  It's here to avoid console errors now.
		function ngRemoveRuffleLoader() { };

		// this is a standalone method flash can use ExternalInterface calls to pull gamepad data.
		// this is for people that want full access to the gamepad info, not just keyboard bindings.
		// keyboard bindings are handled in the script loaded by inputJSScript.
		const getGamepads = ()=>{
			return Array.from(navigator.getGamepads() || [])
			.filter(Boolean)
			.map((gamePad) => ({
				id: gamePad.id,
				index: gamePad.index,
				connected: gamePad.connected,
				buttons: gamePad.buttons.map((button) => button.pressed),
				axes: gamePad.axes,
			}));
		};

		(() => {

			var browsermode = new URLSearchParams(window.location.search).get('browsermode');
			var params = JSON.parse(new URLSearchParams(window.location.search).get('props'));

			let NgRuffleGamepad = null;
			window.addEventListener('message', function (e) {
				if (e?.data?.type === 'ruffleSettingsGamepadMapUpdated') {
					params.activeMap = e.data.activeMap;
					if (NgRuffleGamepad) {
						console.log("we received a message from the game!!:", e.data);
						NgRuffleGamepad.setInputMaps(e.data.activeMap);
					}
				}
			});

			let externalLoaded = false;
			let externalSettings = null;
			let onExternalLoaded = ()=>{  };

			function loadExternalSettings() {
				if (params?.externalSettings?.endpoint && params?.externalSettings?.types?.length && !externalLoaded) {
					
					let getParams = {
						type: params.externalSettings.types
					};

					if (params.externalSettings?.user_id) {
						getParams.user_id = params.externalSettings.user_id;
					}

					const searchParams = [];
					for (const type of getParams.type) {
						searchParams.push('type[]=' + parseInt(type));
					}
					if (getParams.user_id) {
						searchParams.push('user_id=' + parseInt(getParams.user_id));
					}

					const queryString = searchParams.join('&');
					fetch(params.externalSettings.endpoint + '?' + queryString, { method: 'GET' })
						.then(response => response.json())
						.then(data => {
							externalSettings = data;
							externalLoaded = true;
							onExternalLoaded();
						})
						.catch(error => {
							console.error('Error loading external settings:', error);
							externalLoaded = true;
							onExternalLoaded();
				});
					
				} else {
					externalLoaded = true;
					onExternalLoaded();
				}
			}

			function onExternalSettingsReady() {
				return new Promise((resolve) => {
					if (externalLoaded) {
						resolve();
					} else {
						onExternalLoaded = () => {
							resolve();
						}
					}
				});
			}
			
			// just in case the dev wants to know this
			if (!params.vars) params.vars = {};
			params.vars.browsermode = browsermode;
		
			if (params && params.ruffle && params.public_path && params.swf) {

				var preReq = { ruffleJS: 0, inputJS: 0, audio: 0, swf: 0 };
				var clickEvent = 'click';
				var startButton = document.getElementById('startFlashBtn');
				var container = document.getElementById('ruffle_content');

				let icon = params.icon || "https://img.ngfiles.com/defaults/icon-portal-xl.webp";
				startButton.innerHTML = `<div class="icon"><img src="${icon}"/><div class="play-over"></div></div>`;

				if (params.unsupported) {
					document.body.classList.add('small');
				}

				function preReqUpdated() {
					// everything has been loaded/initialized!
					if (preReq.ruffleJS && preReq.inputJS && preReq.audio) {

						let ruffle = window.RufflePlayer.newest();
						let player = ruffle.createPlayer();
						let width = params.width ? params.width : window.width;
						let height = params.height ? params.height : window.height;
						params.vars = params.vars ? params.vars : {};
						params.vars.ngLoadedViaRuffle = 1;

						container.appendChild(player);

						player.ruffle().load({
							publicPath: params.public_path,
							url: params.swf,
							parameters: params.vars,
							autoplay: 'on',
							allowScriptAccess: true,
							allowFullScreen: true,
							forceScale: true,
							scale: 'showAll',
							letterbox: 'fullscreen',
							warnOnUnsupportedContent: params.warnOnUnsupportedContent
						}).then(() => {

							onExternalSettingsReady().then(() => {

								if (externalSettings?.gamePadMap) {
									NgRuffleGamepad = new NgRuffle.External.GamePad(player, externalSettings?.gamePadMap);
								} else {
									NgRuffleGamepad = new NgRuffle.External.GamePad(player, null);
								}

							});
						});

						function scalePlayer(w, h) {

							var windowWidth = window.innerWidth || document.documentElement.clientWidth || document.body.clientWidth;
							var windowHeight = window.innerHeight || document.documentElement.clientHeight || document.body.clientHeight;

							if (browsermode == 'mobile' && windowWidth && windowHeight) {
								if (w > windowWidth) w = windowWidth;
								if (h > windowHeight) h = windowHeight;
							}

							player.style.width = w + "px";
							player.style.height = h + "px";
						}

						window.onresize = function () {
							setTimeout(() => {
								scalePlayer(width, height);
							}, 1);
						};

						scalePlayer(width, height);

					}
				}

				const head = document.getElementsByTagName("head")[0];

				const ruffleJSScript = document.createElement("script");
				ruffleJSScript.onload = function () {
					preReq.ruffleJS = 1;
					preReqUpdated();
				}
				ruffleJSScript.src = params.ruffle;
				head.appendChild(ruffleJSScript);
				
				if (params.external) {
					const inputJSScript = document.createElement("script");

					inputJSScript.onload = function () {
						preReq.inputJS = 1;
						preReqUpdated();
					}
					inputJSScript.src = params.external;
				
					head.appendChild(inputJSScript);
				} else {
					preReq.inputJS = 1;
				}

				startButton.addEventListener(clickEvent, function (e) {
					e.preventDefault();
					e.stopPropagation();
					startButton.remove();

					loadExternalSettings();

					var audioUrl = "data:audio/mp3;base64,SUQzBAAAAAAAI1RTU0UAAAAPAAADTGF2ZjU2LjM2LjEwMAAAAAAAAAAAAAAA//OEAAAAAAAAAAAAAAAAAAAAAAAASW5mbwAAAA8AAAAEAAABIADAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV6urq6urq6urq6urq6urq6urq6urq6urq6v////////////////////////////////8AAAAATGF2YzU2LjQxAAAAAAAAAAAAAAAAJAAAAAAAAAAAASDs90hvAAAAAAAAAAAAAAAAAAAA//MUZAAAAAGkAAAAAAAAA0gAAAAATEFN//MUZAMAAAGkAAAAAAAAA0gAAAAARTMu//MUZAYAAAGkAAAAAAAAA0gAAAAAOTku//MUZAkAAAGkAAAAAAAAA0gAAAAANVVV";

					var audioElement = document.createElement('audio');

					audioElement.addEventListener('playing', function () {
						preReq.audio = 1;
						preReqUpdated();
					});

					document.body.appendChild(audioElement);
					audioElement.setAttribute('src', audioUrl);
					audioElement.load();
					audioElement.play();
				});

			}

		})();
	</script>
</body>

</html>